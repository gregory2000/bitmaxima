<pre class="prettyprint"><code>const Int32 BufferSize = 128;
    using (var fileStream = File.OpenRead(fileName))
    using (var streamReader = new StreamReader(fileStream, Encoding.UTF8, true, BufferSize)) {
    String line;
    while ((line = streamReader.ReadLine()) != null)
    // Process line
    }
</code></pre>

<pre class="prettyprint"><code>var lines = File.ReadLines(fileName);
    foreach (var line in lines)
    // Process line
</code></pre>



<pre class="prettyprint"><code>var lines = File.ReadAllLines(fileName);
    foreach (var line in lines)
    // Process line
</code></pre>


<pre class="prettyprint"><code>using (var streamReader = File.OpenText(fileName)) {
    var lines = streamReader.ReadToEnd().Split("\r\n".ToCharArray(), StringSplitOptions.RemoveEmptyEntries);
    foreach (var line in lines)
    // Process line
    }
</code></pre>



<pre class="prettyprint"><code>using (StreamReader sr = File.OpenText(fileName))
    {
    string s = String.Empty;
    while ((s = sr.ReadLine()) != null)
    {
    //we're just testing read speeds
    }
    }
</code></pre>



<pre class="prettyprint"><code>var filestreams = sr.ReadToEnd().Split("\r\n".ToCharArray(),
    StringSplitOptions.RemoveEmptyEntries);
</code></pre>


<pre class="prettyprint"><code>using (StreamReader sr = File.OpenText(fileName))
    {
    string s = String.Empty;
    while ((s = sr.ReadLine()) != null)
    {
    //we're just testing read speeds
    }
    }
</code></pre>


<pre class="prettyprint"><code>AllLines = new string[MAX]; //only allocate memory here
    using (StreamReader sr = File.OpenText(fileName))
    {
    int x = 0;
    while (!sr.EndOfStream)
    {
    AllLines[x] = sr.ReadLine();
    x += 1;
    }
    } //CLOSE THE FILE because we are now DONE with it.
    Parallel.For(0, AllLines.Length, x =&gt;
    {
    TestReadingAndProcessingLinesFromFile_DoStuff(AllLines[x]); //do your work here
    });
</code></pre>

<pre class="prettyprint"><code>var lines = File.ReadAllLines(fileName);
    foreach (var line in lines)
</code></pre>
